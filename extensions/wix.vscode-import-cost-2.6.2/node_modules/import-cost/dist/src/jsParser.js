'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPackages = getPackages;

var _babelCore = require('babel-core');

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _babylon = require('babylon');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var PARSE_PLUGINS = ['jsx', 'flow', 'asyncFunctions', 'classConstructorCall', 'doExpressions', 'trailingFunctionCommas', 'objectRestSpread', 'decorators', 'classProperties', 'exportExtensions', 'exponentiationOperator', 'asyncGenerators', 'functionBind', 'functionSent'];

function getPackages(fileName, source) {
  var packages = [];
  var visitor = {
    ImportDeclaration: function ImportDeclaration(path) {
      packages.push({
        fileName: fileName,
        name: path.node.source.value,
        line: path.node.loc.end.line,
        string: compileImportString(path.node)
      });
    },
    CallExpression: function CallExpression(path) {
      if (path.node.callee.name === 'require') {
        packages.push({
          fileName: fileName,
          name: getPackageName(path.node),
          line: path.node.loc.end.line,
          string: compileRequireString(path.node)
        });
      }
    }
  };

  var ast = parse(source);
  (0, _babelCore.traverse)(ast, visitor);
  return packages;
}

function parse(source) {
  return (0, _babylon.parse)(source, {
    sourceType: 'module',
    plugins: PARSE_PLUGINS
  });
}

function compileImportString(node) {
  var importSpecifiers = void 0,
      importString = void 0;
  if (node.specifiers && node.specifiers.length > 0) {
    importString = node.specifiers.map(function (specifier, i) {
      if (t.isImportNamespaceSpecifier(specifier)) {
        return '* as ' + specifier.local.name;
      } else if (t.isImportDefaultSpecifier(specifier)) {
        return specifier.local.name;
      } else if (t.isImportSpecifier(specifier)) {
        if (!importSpecifiers) {
          importSpecifiers = '{';
        }
        importSpecifiers += specifier.imported.name;
        if (node.specifiers[i + 1] && t.isImportSpecifier(node.specifiers[i + 1])) {
          importSpecifiers += ', ';
          return undefined;
        } else {
          var result = importSpecifiers + '}';
          importSpecifiers = undefined;
          return result;
        }
      } else {
        return undefined;
      }
    }).filter(function (x) {
      return x;
    }).join(', ');
  } else {
    importString = '* as tmp';
  }
  return 'import ' + importString + ' from \'' + node.source.value + '\';\nconsole.log(' + importString.replace('* as ', '') + ');';
}

function compileRequireString(node) {
  return 'require(\'' + getPackageName(node) + '\')';
}

function getPackageName(node) {
  return t.isTemplateLiteral(node.arguments[0]) ? node.arguments[0].quasis[0].value.raw : node.arguments[0].value;
}